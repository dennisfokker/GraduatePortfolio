<!DOCTYPE html>
<html>

    <head>
        <!-- Standard Meta -->
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0">

        <!-- Site Properties -->
        <title>DFokker Portfolio - Arduino Communication</title>

        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/semantic-ui@2.4.2/dist/semantic.min.css">

        <link rel="stylesheet" type="text/css" href="css/home.css">
        <link rel="stylesheet" type="text/css" href="css/main-product.css">

        <script src="https://code.jquery.com/jquery-3.1.1.min.js" integrity="sha256-hVVnYaiADRTO2PzUGmuLJr8BLUSjGIZsDYGmIJLv2b8=" crossorigin="anonymous"></script>
        <script src="https://cdn.jsdelivr.net/npm/semantic-ui@2.4.2/dist/semantic.min.js"></script>
    </head>

    <body>
        <a href="index.html">
            <div class="banner ui inverted vertical center aligned segment">
                <div class="ui text container">
                    <h1 class="ui inverted header">Graduate Portfolio</h1>
                </div>
            </div>
        </a>


        <div class="ui inverted three item important attached menu">
            <div class="ui centered aligned container">

                <a class="item" href="index.html">
                    Home
                </a>

                <div class="ui simple dropdown active item">
                    Products <i class="dropdown icon"></i>
                    <div class="menu">

                        <a class="item" href="hand-collision.html">Hand collision</a>
                        
                        <div class="active item">Arduino communication</div>

                        <a class="item" href="screenshot-tool.html">Screenshot tool</a>

                        <a class="item" href="license-spring.html">License Spring</a>

                        <div class="item">
                            Product 2 <i class="dropdown icon"></i>
                            <div class="menu">
                                <a class="item">Sub Product 2.1</a>

                                <a class="item">Sub Product 2.2</a>
                            </div>
                        </div>

                    </div>
                </div>

                <a class="item">
                    About internship
                </a>

            </div>
        </div>

        <div class="ui container basic segment content">
            <div class="ui vertical center aligned segment">
                <h1 class="ui title header">ARDUINO COMMUNICATION</h1>
                <div class='embed-container'>
                    <iframe src='https://www.youtube.com/embed/G3bEBgGWmeg?controls=0&autoplay=1&loop=1&mute=1&playlist=G3bEBgGWmeg' frameborder='0'></iframe>
                </div>
                
                <div class="intro">
                        <p>Some of the games in the PROTO game-collection use input from physical machines. These machines have their hardware's data run through an Arduino and from there over to the PC that runs the game.</p>
                        <p>This communication can also go backwards, where the game communicates information with the Arduino.</p>
                </div>
            </div>

            <div class="ui vertical stripe segment">
                <div class="ui basic center aligned segment">
                    <h1 class="ui title header">CONCEPT</h1>
                </div>

                <div class="ui divided grid">
                    <div class="eight wide column">
                        <h4 class="ui title header">Provided by PROTO</h4>
                        <p>An outside source (company) provides hardware (e.g. a bike), which includes an Arduino and code to process the hardware’s input (e.g. a tilt sensor).</p>
                        <p>The Arduino will format any input to a -1 to 1 scale (like how a joystick would function) based on its calibration settings. All hardware input is gathered into a single message and sent over a COM port to the connected computer. It has been agreed that all messages are sent over in a JSON format.</p>

                        <div class="ui section divider"></div>

                        <h4 class="ui title header">Actions for Enversed</h4>
                        <p>When we received the testing hardware, the first thing we had to do is validate it: update calibration data and assure the input is formatted into the correct message. If this is not the case this has to be updated by us (Arduino C++ code).</p>
                        <p>Once the hardware is set up, we can dive into the game. First we have to connect to the Arduino, after which we can receive the JSON messages and inform the rest of the game.</p>
                    </div>

                    <div class="eight wide column">
                        <h4 class="ui title header">Document required tasks</h4>
                        <p>The first tasks were already clear: make sure the games work with the supplied hardware (Arduinos). While this was all we had to worry about for a long time, eventually additional requirements came: a management subsystem. This subsystem comes in the form of a Raspberry Pi and accepts player scores from the game, which can be claimed by the player.</p>
                        <p>While we already knew this subsystem would have to be implemented, it took some time before PROTO came with their specifications. Once we received their specifications I wrote down all the tasks that would have to be performed. From these tasks the PO can create an estimated amount of time to implement, and by extend a quotation.</p>
                        <p>The first and final version can be found below. Note that the final version mainly has a lot of components removed, these were decisions made by the client.</p>

                        <a class="ui big blue label" href="" target="_blank">
                            <i class="dropbox icon"></i>First version task specifications
                        </a>
                        <a class="ui big blue label" href="" target="_blank">
                            <i class="dropbox icon"></i>Final version task specifications
                        </a>
                    </div>
                </div>

                <div class="ui grid">
                    <div class="ten wide column">
                    </div>

                    <div class="ten wide column">
                    </div>
                </div>
            </div>

            <div class="ui vertical stripe segment">
                <div class="ui basic center aligned segment">
                    <h1 class="ui title header">DEVELOPMENT</h1>
                </div>

                <div class="ui grid">
                    <div class="nine wide column">
                        <p>Once the set up has been finished at Enversed’s side, the implementation can start. There are three subjects to this: <b>Connecting</b>, <b>Protocol</b> and the <b>Sidenotes</b> resulting from the connection implementation.</p>
                        <p>The source of the Arduino communication plugin can be found <a href="https://www.dropbox.com/sh/fgzse0m8ez08pj3/AAD2N1entVHaAHtijuiPHt0fa?dl=0" target="_blank">here</a>.</p>

                        <div class="ui fluid card">
                            <div class="content">
                                <div class="header">Connecting</div>
                                <div class="description">
                                    Connect and read from the Arduino COM port, serving it to the game in a useful format.
                                </div>
                            </div>
                            <div id="connecting" class="ui bottom attached blue button">
                                <i class="comment alternate outline icon"></i>
                                Read more
                            </div>
                        </div>

                        <div class="ui fluid card">
                            <div class="content">
                                <div class="header">Protocol</div>
                                <div class="description">
                                    Hardware can fail, messages can get corrupted. A protocol has been created that should ensure the correct message will be received in the end.
                                </div>
                            </div>
                            <div id="protocol" class="ui bottom attached blue button">
                                <i class="comment alternate outline icon"></i>
                                Read more
                            </div>
                        </div>

                        <div class="ui fluid card">
                            <div class="content">
                                <div class="header">Sidenotes</div>
                                <div class="description">
                                        Several things to keep in mind when using this system. There also is a suggestion on how to resolve crashes, as that will be the result of incorrect implementation.
                                </div>
                            </div>
                            <div id="sidenotes" class="ui bottom attached blue button">
                                <i class="comment alternate outline icon"></i>
                                Read more
                            </div>
                        </div>
                    </div>

                    <div class="seven wide column">
                        <h4 class="ui title header">FLOWCHART</h4>
                        <div id="flowchart">
                            <img class="ui fluid image zoomable" src="assets/images/arduino-communication/flowchart.png">
                            <div class="ui dimmer">
                                <div class="content">
                                    <h1 class="ui inverted icon header">
                                        <i class="search plus icon"></i>
                                        Zoom in
                                    </h1>
                                </div>
                            </div>
                        </div>
                        
                        <h4 class="ui title header">HARDWARE</h4>
                        <div id="hardware">
                            <img class="ui fluid image zoomable" src="assets/images/arduino-communication/hardware.jpg">
                            <div class="ui dimmer">
                                <div class="content">
                                    <h1 class="ui inverted icon header">
                                        <i class="search plus icon"></i>
                                        Zoom in
                                    </h1>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="ui vertical stripe segment">
                <div class="ui basic center aligned segment">
                    <h1 class="ui title header">PROCESS</h1>
                </div>

                <div class="ui divided grid">
                    <div class="eight wide column">
                        <h4 class="ui title header">CONNECTING - PARSING</h4>
                        <p>As mentioned, the base for the arduino communication was already mostly there.</p>
                        <p>Initially the Arduino boards would just send over a JSON string on it’s baud rate (developed by PROTO). This however quickly became an issue with detecting said message in the game. How do we know when the message has started and where it’ll end?</p>
                        <p>It wasn’t an option to essentially interpret the JSON with every byte we received and work based off that. Instead we pitched the idea of the STX (Start Text) and ETX (End Text) characters. These would encapsulate the message so we would know when a message starts and when it ends.</p>
                        <p>This also helped as protection against data loss/corruption. Imagine defining the end of a message by a matching amount of opening and closing curly brackets. Missing one closing bracket would just mean they’d never match up again some other fortunate corruption would happen later on. Now we only need to see a single character after which we can discard the message if it’s not valid JSON (due to corruption).</p>

                        <h4 class="ui title header">CONNECTING - CALIBRATION</h4>
                        <p>We animate the Arduino’s input onto a mesh in the game (1:1 to the physical setup). The Arduino’s hardware needs tweaking, however (how many degrees of turning the steer should return the value 1). This calibration data is sent over from the Arduino on setup, which is fired when connecting to the Arduino from the game. This follows the same conventions of a start/end character and a JSON message.</p>
                        <p>This was implemented so that the “in-game” calibration can be done from the Arduino. That way we don’t have to send over a new build if their physical setup is different compared to the test setups we received.</p>
                    </div>
                    
                    <div class="eight wide column">
                        <h4 class="ui title header">PROTOCOL - SENDING DATA</h4>
                        <p>The initial idea behind adhering to the protocol for sending was to use latent functions on the blueprint side. The issue with latent functions was that we couldn’t find any sources to implement it with multiple out execution pins and return values. Aside from this limitation we also noticed that the structure of a latent function wouldn’t play nicely with our multithreaded structure.</p>
                        <p>In the end we opted to do it in a more manual method: work on the “Arduino threat” and start up timers whenever required. This system will be able to call delegates and BP events when required. On the blueprint side we can then keep track of the current Arduino “state” (e.g. performing handshake) and react on the success or failure of sending a message accordingly.</p>
                        
                        <h4 class="ui title header">PROTOCOL - TIMER EVENTS</h4>
                        <p>As mentioned in “PROTOCOL - SENDING DATA”, we’re using timers to implement the waits the protocol specifies. Timers have several different methods of calling a delegate on completion. By default, you would use a parameter-less function. This, however, wouldn’t do. We needed to send over data (the received message on start of the timer).</p>
                        <p>There were a few options proposed:</p>
                        <ul>
                            <li>Store the message in a field that we read upon reaching the parameter-less function.</li>
                            <li>Use a function that does accept parameters, binding the timer to this function.</li>
                            <li>Use a lambda function that the timer is bound to.</li>
                        </ul>
                        <p>In the end the lambda function was the chosen implementation, as it centralizes the (small bits of) implementation of a theoretical “OnTimerXCompleted”-function; it’s right next to it.</p>
                        <div id="lambda-timer">
                            <img class="ui fluid image zoomable" src="assets/images/arduino-communication/lambda_timer.png">
                            <div class="ui dimmer">
                                <div class="content">
                                    <h1 class="ui inverted icon header">
                                        <i class="search plus icon"></i>
                                        Zoom in
                                    </h1>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>


        <div class="ui inverted vertical footer segment">
            <img class="ui left floated medium image" src="assets/images/enversed-banner.png">
        </div>



        <div id="flowchart-modal" class="ui basic modal">
            <i class="close icon"></i>
            <div class="header">Flowchart</div>
            <div class="content">
                <img class="ui fluid image" src="assets/images/arduino-communication/flowchart.png">
            </div>
        </div>



        <div id="hardware-modal" class="ui basic modal">
            <i class="close icon"></i>
            <div class="header">Hardware</div>
            <div class="content">
                <img class="ui fluid image" src="assets/images/arduino-communication/hardware.jpg">
            </div>
        </div>



        <div id="lambda-timer-modal" class="ui basic modal">
            <i class="close icon"></i>
            <div class="header">Lambda Timer Example</div>
            <div class="content">
                <img class="ui fluid image" src="assets/images/arduino-communication/lambda_timer.png">
            </div>
        </div>



        <div id="connecting-modal" class="ui modal">
            <i class="close icon"></i>
            <div class="header">Connecting</div>
            <div class="content">
                <p>The base of communication is done through the free open source UE4 plugin <a href="https://github.com/RVillani/UE4Duino" target="_blank">UE4Duino</a>. With this, we added a custom C++ component that simplifies the communication.</p>
                <p>The component only requires a single setup function and separate functions to start/stop reading the COM port (takes care of actions like flushing the buffer). Aside from that you can bind to an event which will return received messages, already neatly formatted into a dictionary.</p>
                <p>The most complex system here is the event dispatcher. The component needs to make sure the message has properly started and ended, so that there will be no issues during deserialization.</p>
                <p>An important part of reading the COM port is that it’s happening on a separate thread: there’s more than one message sent per tick. This means that data comes in constantly and would easily lock up the game thread. Running the reading code on a new thread would fix this, as it can peacefully process all messages whenever received. Luckily all that has to be done with this data is put it in their respective variables, so it can be processed by the rest of the game. Since UE4 makes sure that all variables are thread-safe there’s no risk of memory access violations when used <u data-tooltip="See the sidenotes about what exactly is meant by “properly”." data-inverted="">properly*</u>.</p>
            </div>
        </div>



        <div id="protocol-modal" class="ui modal">
            <i class="close icon"></i>
            <div class="header">Protocol</div>
            <div class="content">
                <div class="ui grid">
                    <div class="ten wide column">
                        <p>Arduino communication goes over a COM port, typically USB. A USB port means hardware, which can cause data corruption or loss (not to mention the wiring in the Arduino itself potentially containing further points of failure).</p>
                        <p>In order to assure all messages are received correctly, PROTO has set up a protocol that has to be followed when sending and receiving messages. The protocol handles several situations, such as complete loss of messages or a corruption of the data somewhere in the transmission. The diagram on the right shows their protocol.</p>
                        <p>Plainly sending information over a COM port is something that’s already contained in the plugin’s base, so only the logic of the protocol is something that we need to worry about.</p>
                    </div>
                    <div class="six wide column">
                        <div id="protocol-diagram">
                            <img class="ui fluid image zoomable" src="assets/images/arduino-communication/protocol_diagram.png">
                            <div class="ui dimmer">
                                <div class="content">
                                    <h1 class="ui inverted icon header">
                                        <i class="search plus icon"></i>
                                        Zoom in
                                    </h1>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                <p>The receiving side is easiest: when we’re not busy trying to send something, just echo back whatever you receive. After a short silence (250ms) you will know you received the correct message without any corruption and it can be sent over to the rest of the system.</p>
                <p>Sending is a bit more complex: it contains retries (every 100ms) if no echo was received (message lost) and a check on the echo to see if the message got corrupted somewhere along the line or not. Finally, just like receiving, it contains a delay (250ms) to catch any noise or buffered messages, at which point it might decide to either resend the message or restart the delay, which will indicate a successful send on completion.</p>
            </div>
        </div>



        <div id="sidenotes-modal" class="ui modal">
            <i class="close icon"></i>
            <div class="header">Sidenotes</div>
            <div class="content">
                <p><i>It’s important to first read the previous subjects, otherwise these sidenotes will make no sense.</i></p>
                <p>As mentioned, message reading in done on an extra thread. When the messages are processed properly there won’t be any issues. A good rule for this is to only change <b>data</b> and not <b>physical attributes</b>. Data essentially just means a normal variable. Physical attributes refer to information that’s relevant to the game world, like an actor’s location or dynamically generating a material.</p>
                <p>Failing to follow this rule will almost certainly crash your game, as these operations are not supported in a multi-threaded context.</p>
                <p>When a crash does happen, it might not be quite as straightforward to find out what exactly you’re doing wrong. If an initial scan doesn’t show the culprit, process of elimination is likely your best bet.</p>
                <p>Once you have an easily reproducible setup made, start disconnecting code until it starts working again. If you already have an idea where it might be, start by disconnecting that. No idea? Just disconnect the entire message handling code. Still crashed? Then it’s either something in the plugin or some other system that’s failing.</p>
                <p>Using this function it’s all a matter of slowly closing in on the faulty code, at which point the relevant code can be moved away from the threaded event and to a point which actually runs on the game thread (like tick).</p>
            </div>
        </div>



        <div id="protocol-diagram-modal" class="ui basic modal">
            <i class="close icon"></i>
            <div class="header">Protocol diagram</div>
            <div class="content">
                <img class="ui fluid image" src="assets/images/arduino-communication/protocol_diagram.png">
            </div>
        </div>



        <script type="text/javascript">
            $('#flowchart').click(function ()
            {
                $('#flowchart-modal').modal('show');
            }).dimmer({
                on: 'hover'
            });

            $('#hardware').click(function ()
            {
                $('#hardware-modal').modal('show');
            }).dimmer({
                on: 'hover'
            });

            $('#lambda-timer').click(function ()
            {
                $('#lambda-timer-modal').modal('show');
            }).dimmer({
                on: 'hover'
            });

            $('#protocol-diagram').click(function ()
            {
                $('#protocol-diagram-modal').modal('show');
            }).dimmer({
                on: 'hover'
            });

            $('#connecting').click(function ()
            {
                $('#connecting-modal').modal('show');
            });

            $('#protocol').click(function ()
            {
                $('#protocol-modal').modal('show');
            });

            $('#sidenotes').click(function ()
            {
                $('#sidenotes-modal').modal('show');
            });
        </script>
    </body>
</html>
